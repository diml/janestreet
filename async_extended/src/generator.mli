(** A generator is a consumer-driven source of data.  Unlike Async streams, these
 *  objects are stateful.  For example, if one generator is shared between two clients
 *  that both invoke [next], then they will see different sequences of items *)


open! Core
open! Async

type 'a t

val empty : 'a t

val create : (unit -> [`Done | `Ok of 'a] Deferred.t) -> 'a t

val unfold : 'state -> ('state -> [`Done | `Ok of 'a * 'state] Deferred.t) -> 'a t

(** [singleton x] creates a generator containing only x. *)
val singleton : 'a -> 'a t

val of_list : 'a list -> 'a t

(** [find gen ~f] finds the first item for which [f item] is true.
  @return first item in generator for which [f item] is true, 
  or None if no such element is found. *)
val find : 'a t -> f:('a -> bool) -> 'a option Deferred.t

val fold' : 'a t -> init:'b -> f:('b -> 'a -> 'b Deferred.t) -> 'b Deferred.t

val fold : 'a t -> init:'b -> f:('b -> 'a -> 'b) -> 'b Deferred.t

val iter' : 'a t -> f:('a -> unit Deferred.t) -> unit Deferred.t

val iter : 'a t -> f:('a -> unit) -> unit Deferred.t

(** Generates all elements from generator and returns the resulting list. 
    @return list of elements generated in the order in which they were generated. *)
val to_list : 'a t -> ('a list) Deferred.t

(** [map' t f] creates a new generator that with the result of the deferred (f v), 
    for each element v of t. *)
val map' : 'a t -> f:('a -> 'b Deferred.t) -> 'b t

(** [map t f] creates a new generator that with one element, (f v), for each
    element v of t. *)
val map : 'a t -> f:('a -> 'b) -> 'b t

val filter_map : 'a t -> f:('a -> 'b option) -> 'b t

val filter_opt : 'a option t -> 'a t

val next : 'a t -> [`Done | `Ok of 'a] Deferred.t

val to_stream : 'a t -> 'a Stream.t

(** [append t1 t2] creates a new generator that first echos [t1] until it is
    done, then echos [t2] *)
val append : 'a t -> 'a t -> 'a t

(** [concat t] creates a new generator echos in sequence
    each generator generated by [t] *)
val concat : 'a t t -> 'a t

